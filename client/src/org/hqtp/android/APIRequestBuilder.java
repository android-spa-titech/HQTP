package org.hqtp.android;

import java.io.IOException;
import java.io.UnsupportedEncodingException;
import java.nio.charset.Charset;
import org.apache.http.HttpEntity;
import org.apache.http.HttpResponse;
import org.apache.http.HttpStatus;
import org.apache.http.client.ClientProtocolException;
import org.apache.http.client.CookieStore;
import org.apache.http.client.ResponseHandler;
import org.apache.http.client.methods.HttpGet;
import org.apache.http.client.methods.HttpPost;
import org.apache.http.client.methods.HttpUriRequest;
import org.apache.http.impl.client.DefaultHttpClient;
import org.apache.http.util.EntityUtils;
import org.apache.http.entity.mime.HttpMultipartMode;
import org.apache.http.entity.mime.MultipartEntity;
import org.apache.http.entity.mime.content.StringBody;

import android.app.Application;
import android.net.Uri;

import com.google.inject.Inject;
import com.google.inject.name.Named;
import com.loopj.android.http.PersistentCookieStore;

/**
 * An agent for issuing HttpRequest of API
 * To issue an APIRequest, there are many cumbersome works like building URL or preserve a cookie.
 * This class will do them for you.
 * If you bind a URI String to "HQTP API Endpoint URL", this class will use it as default api_gateway.
 */
public final class APIRequestBuilder {
    private Uri api_gateway;
    private CookieStore cookie_store;

    @Inject
    public APIRequestBuilder(@Named("HQTP API Endpoint URL") String api_gateway, Application application) {
        this.api_gateway = Uri.parse(api_gateway);
        this.cookie_store = new PersistentCookieStore(application);
    }

    /**
     * Reset the API gateway.
     * 
     * @param api_gateway
     */
    public void setEndpoint(String api_gateway) {
        this.api_gateway = Uri.parse(api_gateway);
    }

    public APIRequest get(String path) {
        return new GETRequest(path);
    }

    public APIRequest post(String path) {
        return new POSTRequest(path);
    }

    /**
     * A class that represents API request
     */
    public abstract class APIRequest {
        public APIRequest param(String key, int value) {
            return param(key, Integer.toString(value));
        }

        public APIRequest param(String key, long value) {
            return param(key, Long.toString(value));
        }

        public abstract APIRequest param(String key, String value);

        public abstract String send() throws ClientProtocolException, IOException, HQTPAPIException;

        /**
         * Issue a request and return the result.
         * Throw a HQTPAPIException when the HTTP status code is not OK or CREATED. If there is some networking issue,
         * this will throw an exception too. This method automatically uses and stores cookies. This cookie is shared by
         * all requests generated by the same builder.
         * 
         * @param request
         * @return a HttpResponse object
         * @throws ClientProtocolException
         * @throws IOException
         * @throws HQTPAPIException
         */
        protected String send(HttpUriRequest request) throws ClientProtocolException, IOException,
                HQTPAPIException {
            DefaultHttpClient client = new DefaultHttpClient();
            client.setCookieStore(cookie_store);
            String response_str;
            try {
                response_str = client.execute(request, new StringResponseHandler());
            } catch (ClientProtocolException e) {
                throw new HQTPAPIException(e.getMessage());
            } finally {
                client.getConnectionManager().shutdown();
            }

            cookie_store = client.getCookieStore();
            return response_str;
        }

        /**
         * A class that converts HttpResponse to String with some checks.
         * It is strange but this way is safer than the way to treat HttpResponse returned by
         * DefaultHttpClient.execute(HttpUriRequest).
         */
        private class StringResponseHandler implements ResponseHandler<String> {
            @Override
            public String handleResponse(HttpResponse response) throws ClientProtocolException, IOException {
                final int status_code = response.getStatusLine().getStatusCode();
                if (status_code != HttpStatus.SC_OK && status_code != HttpStatus.SC_CREATED) {
                    throw new ClientProtocolException("HTTP response returned failure. : return Http status code="
                            + Integer.toString(status_code));
                }

                HttpEntity entity = response.getEntity();
                String response_str = EntityUtils.toString(entity);
                entity.consumeContent();
                return response_str;
            }
        }
    }

    /**
     * A class that represents GET API Request.
     */
    private final class GETRequest extends APIRequest {
        private Uri.Builder builder;

        public GETRequest(String path) {
            builder = api_gateway.buildUpon();
            builder.appendEncodedPath(path);
        }

        @Override
        public APIRequest param(String key, String value) {
            builder.appendQueryParameter(key, value);
            return this;
        }

        @Override
        public String send() throws ClientProtocolException, IOException, HQTPAPIException {
            return send(new HttpGet(builder.build().toString()));
        }
    }

    /**
     * A class that represents POST API Request.
     */
    private final class POSTRequest extends APIRequest {
        private final String uri;
        private MultipartEntity entity = new MultipartEntity(HttpMultipartMode.BROWSER_COMPATIBLE);

        public POSTRequest(String path) {
            Uri.Builder builder = api_gateway.buildUpon();
            builder.appendEncodedPath(path);
            uri = builder.build().toString();
        }

        @Override
        public APIRequest param(String key, String value) {
            try {
                entity.addPart(key, new StringBody(value, Charset.forName("UTF-8")));
            } catch (UnsupportedEncodingException e) {
                // Maybe unreachable...
                e.printStackTrace();
            }
            return this;
        }

        @Override
        public String send() throws ClientProtocolException, IOException, HQTPAPIException {
            HttpPost request = new HttpPost(uri);
            //TODO: check entity is empty?
            request.setEntity(entity);
            return send(request);
        }
    }
}
